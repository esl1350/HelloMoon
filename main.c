#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/start.h"
#include "images/gamescreen.h"
#include "images/cow.h"
#include "images/gameover.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  LOADING,
  PLAY,
  WIN,
  LOADLOSE,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  int buttonWasDown[10] = {0};
  int buttonJustReleased[10] = {0};
  int score = 0;
  int cowCounter = 0;
  struct cowSprite myCow, myPrevCow;
  int yMove = 10;
  myCow.x = 10;
  myCow.y = 30;
  myCow.xSpeed = 0;
  myPrevCow.x = 10;
  myPrevCow.y = 30;
  myPrevCow.xSpeed = 0;

  int scoreChange = 0;
  int bounced = 0;
  struct moonSprite moon;
  moon.xBound = 182;
  moon.yBound = 110;
  // Load initial application state
  enum gba_state state = START;
  
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    for (int i = 0; i < 10; i++) {
      buttonJustReleased[i] = (KEY_DOWN(i, BUTTONS) == 0 && buttonWasDown[i]);
      buttonWasDown[i] = (KEY_DOWN(i, BUTTONS) != 0);
    }
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    if (buttonJustReleased[BUTTON_SELECT]) {
      state = START;
    }
    waitForVBlank();
    switch (state) {
      case START:
        yMove = 10;
        myCow.x = 10;
        myCow.y = 30;
        myCow.xSpeed = 0;
        myPrevCow.x = 10;
        myPrevCow.y = 30;
        myPrevCow.xSpeed = 0;
        score = 0;
        cowCounter = 0;
        scoreChange = 0;
        bounced = 0;
        drawFullScreenImageDMA(start);
        char playLabel[] = "press start to play!";
        drawCenteredString(120, 120, 1, 1, playLabel, 0xffff);
        if (buttonJustReleased[BUTTON_START]) {
          state = LOADING;
        }
        break;
      case LOADING:
        drawFullScreenImageDMA(gamescreen);
        state = PLAY;
        break;
      case PLAY:;
        myPrevCow = myCow;
        myCow.x = myCow.x + myCow.xSpeed;
        if (buttonJustReleased[BUTTON_DOWN] && myCow.xSpeed == 0) {
          if (myCow.y + yMove < 120) {
            myCow.y = myCow.y + yMove;
          } else {
            myCow.y = 120;
          }
          drawImageDMA(myPrevCow.y, myPrevCow.x, 30, 10, gamescreen);
        }
        if (buttonJustReleased[BUTTON_UP] && myCow.xSpeed == 0) {
          if (myCow.y - yMove > 31) {
            myCow.y = myCow.y - yMove;
          } else {
            myCow.y = 30;
          }
          drawImageDMA(myCow.y+30, myPrevCow.x, 30, 20, gamescreen);
        }
        if (buttonJustReleased[BUTTON_A] && myCow.xSpeed == 0) {
          myCow.xSpeed = 2;
        }
        if((myCow.y >= moon.yBound-30) && myCow.x > (moon.xBound-30)) {
          myCow.x = moon.xBound-30;
          myCow.xSpeed = -myCow.xSpeed;
          bounced = 1;
        }
        if (myCow.xSpeed > 0) {
          drawImageDMA(myPrevCow.y, myPrevCow.x, 30, 1, gamescreen);
        } else if (myCow.xSpeed < 0 && myCow.x < moon.xBound-32) {
          drawImageDMA(myPrevCow.y, myPrevCow.x+30, 2, 30, gamescreen);
        }
        if (myCow.x >= 210) {
          if (cowCounter == 0) {
            drawImageDMA(myPrevCow.y, myPrevCow.x, 30, 30, gamescreen);
            score++;
            scoreChange = 1;
          }
          cowCounter++;
        }
        if (myCow.x <= 100 && bounced) {
          state = LOADLOSE;
        }
        if (cowCounter == 100) {
          myCow.x = 10;
          myCow.y = 30;
          myCow.xSpeed = 0;
          cowCounter = 0;
        }
        setPixel(100, 100, 0xffff);
        setPixel(120, 80, 0xffff);
        setPixel(50, 50, 0xffff);
        setPixel(20, 175, 0xffff);
        setPixel(80, 160, 0xffff);
        setPixel(110, 40, 0xffff);
        setPixel(150, 170, 0xffff);
        setPixel(30, 18, 0xffff);
        setPixel(130, 18, 0xffff);
        setPixel(70, 120, 0xffff);
        setPixel(80, 220, 0xffff);
        setPixel(13, 189, 0xffff);
        setPixel(93, 120, 0xffff);
        setPixel(80, 160, 0xffff);
        setPixel(130, 89, 0xffff);
        if (cowCounter == 0) {
          drawImageDMA(myCow.y, myCow.x, 30, 30, cow);
        }
        char bufferString[51];
        if (scoreChange) {
          drawRectDMA(10, 80, 30, 30, 0x20a5);
          scoreChange = 0;
        }
        sprintf(bufferString, "cows thrown: %d", score);
        waitForVBlank();
        drawString(10, 10, bufferString, 0xffff);
        break;
      case WIN:
        // state = ?
        break;
      case LOADLOSE:
        drawFullScreenImageDMA(gameover);
        state = LOSE;
        break;
      case LOSE:;
        char bufferScore[51];
        char restart[] = "press start to retry!";
        char gameOver[] = "game over :(";
        sprintf(bufferScore, "final score: %d", score);
        drawCenteredString(50, 120, 1, 1, gameOver, 0xffff);
        drawCenteredString(80, 120, 1, 1, restart, 0xffff);
        drawCenteredString(20, 120, 1, 1, bufferScore, 0xffff);
        
        if (buttonJustReleased[BUTTON_START]) {
          state = START;
        }
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
